<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>MAQSADBEK - Mindmap Builder</title>
    <style>
        /*
        ========================================
        MAQSADBEK MINDMAP BUILDER
        ========================================
        
        CUSTOMIZATION GUIDE:
        
        1. NODE STYLES:
           - Modify .node class for default node appearance
           - Change neon colors in .node.color-green, .node.color-cyan, .node.color-purple
           - Adjust node padding, border-radius in .node
        
        2. NEON THEMES:
           - Add new colors by creating .node.color-yourcolor with box-shadow and border-color
           - Update the COLOR_PRESETS array in JavaScript
        
        3. CONNECTION LINES:
           - Line drawing happens in drawConnections() function
           - Modify ctx.strokeStyle for line color
           - Change ctx.lineWidth for thickness
           - Adjust curve in quadraticCurveTo for line shape
        
        4. JSON IMPORT/EXPORT:
           - exportMindmap() serializes nodes and connections to JSON
           - importMindmap() deserializes and recreates the mindmap
           - Format: { nodes: [...], connections: [...], metadata: {...} }
        
        5. KEYBOARD SHORTCUTS:
           - Add more in handleKeyboard() function
           - Follow pattern: if (e.key === 'yourkey' && e.ctrlKey) { ... }
        
        6. ANIMATIONS:
           - Scanline animation in @keyframes scanline
           - Flicker in @keyframes flicker
           - Glow pulse in @keyframes glow-pulse
        
        ========================================
        */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', Courier, monospace;
            background: #0b0b0b;
            color: #39ff14;
            overflow: hidden;
            height: 100vh;
            position: relative;
        }
        
        /* Scanline overlay for hacker effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 1000;
            animation: scanline 8s linear infinite;
        }
        
        @keyframes scanline {
            0% { transform: translateY(0); }
            100% { transform: translateY(10px); }
        }
        
        /* ASCII Banner */
        #ascii-banner {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #39ff14;
            text-shadow: 0 0 10px #39ff14, 0 0 20px #39ff14;
            z-index: 999;
            white-space: pre;
            animation: flicker 3s infinite;
            user-select: none;
            pointer-events: none;
        }
        
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
            51% { opacity: 1; }
            60% { opacity: 0.9; }
        }
        
        /* Background watermark */
        #bg-watermark {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            color: rgba(57, 255, 20, 0.03);
            font-weight: bold;
            z-index: 0;
            pointer-events: none;
            user-select: none;
        }
        
        /* Main container */
        #app {
            display: flex;
            height: 100vh;
            position: relative;
            z-index: 1;
        }
        
        /* Sidebar */
        #sidebar {
            width: 250px;
            background: rgba(15, 15, 15, 0.95);
            border-right: 2px solid #39ff14;
            padding: 20px;
            overflow-y: auto;
            transition: transform 0.3s ease;
            z-index: 100;
        }
        
        #sidebar.collapsed {
            transform: translateX(-250px);
        }
        
        #sidebar h2 {
            color: #00f5ff;
            margin-bottom: 20px;
            text-align: center;
            font-size: 18px;
            text-shadow: 0 0 10px #00f5ff;
        }
        
        .btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            background: rgba(57, 255, 20, 0.1);
            border: 1px solid #39ff14;
            color: #39ff14;
            cursor: pointer;
            font-family: 'Courier New', Courier, monospace;
            font-size: 12px;
            transition: all 0.3s;
            text-transform: uppercase;
        }
        
        .btn:hover {
            background: rgba(57, 255, 20, 0.3);
            box-shadow: 0 0 10px #39ff14;
        }
        
        .btn:active {
            transform: scale(0.95);
        }
        
        .btn.danger {
            border-color: #ff0066;
            color: #ff0066;
            background: rgba(255, 0, 102, 0.1);
        }
        
        .btn.danger:hover {
            background: rgba(255, 0, 102, 0.3);
            box-shadow: 0 0 10px #ff0066;
        }
        
        #toggle-sidebar {
            position: fixed;
            top: 120px;
            left: 10px;
            z-index: 101;
            padding: 10px 15px;
            background: rgba(15, 15, 15, 0.95);
            border: 1px solid #39ff14;
            color: #39ff14;
            cursor: pointer;
            font-family: 'Courier New', Courier, monospace;
        }
        
        /* Canvas container */
        #canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            cursor: grab;
        }
        
        #canvas-container.panning {
            cursor: grabbing;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        
        /* Nodes */
        .node {
            position: absolute;
            min-width: 100px;
            max-width: 300px;
            padding: 15px;
            background: rgba(15, 15, 15, 0.9);
            border: 2px solid #39ff14;
            border-radius: 8px;
            color: #39ff14;
            cursor: move;
            user-select: none;
            transition: box-shadow 0.3s;
            font-size: 14px;
            word-wrap: break-word;
            box-shadow: 0 0 15px rgba(57, 255, 20, 0.5);
            z-index: 10;
        }
        
        .node:hover {
            box-shadow: 0 0 25px rgba(57, 255, 20, 0.8);
        }
        
        .node.selected {
            border-color: #00f5ff;
            box-shadow: 0 0 30px rgba(0, 245, 255, 1);
            animation: glow-pulse 2s infinite;
        }
        
        @keyframes glow-pulse {
            0%, 100% { box-shadow: 0 0 30px rgba(0, 245, 255, 1); }
            50% { box-shadow: 0 0 50px rgba(0, 245, 255, 1); }
        }
        
        .node.color-green {
            border-color: #39ff14;
            box-shadow: 0 0 15px rgba(57, 255, 20, 0.5);
        }
        
        .node.color-cyan {
            border-color: #00f5ff;
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.5);
        }
        
        .node.color-purple {
            border-color: #b026ff;
            box-shadow: 0 0 15px rgba(176, 38, 255, 0.5);
        }
        
        .node-text {
            outline: none;
            color: inherit;
            background: transparent;
            border: none;
            width: 100%;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
        }
        
        /* Context Menu */
        #context-menu {
            position: fixed;
            background: rgba(15, 15, 15, 0.98);
            border: 2px solid #39ff14;
            padding: 5px;
            z-index: 1001;
            display: none;
            min-width: 180px;
        }
        
        .context-item {
            padding: 10px;
            cursor: pointer;
            color: #39ff14;
            border-bottom: 1px solid rgba(57, 255, 20, 0.2);
        }
        
        .context-item:hover {
            background: rgba(57, 255, 20, 0.2);
        }
        
        .context-item:last-child {
            border-bottom: none;
        }
        
        /* Modal */
        #modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: center;
        }
        
        #modal.active {
            display: flex;
        }
        
        .modal-content {
            background: #0f0f0f;
            border: 2px solid #39ff14;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .modal-content h3 {
            color: #00f5ff;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00f5ff;
        }
        
        .modal-content textarea {
            width: 100%;
            height: 300px;
            background: rgba(57, 255, 20, 0.05);
            border: 1px solid #39ff14;
            color: #39ff14;
            font-family: 'Courier New', Courier, monospace;
            padding: 10px;
            margin-bottom: 15px;
            resize: vertical;
        }
        
        .modal-buttons {
            display: flex;
            gap: 10px;
        }
        
        /* Info panel */
        #info-panel {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(15, 15, 15, 0.9);
            border: 1px solid #39ff14;
            padding: 10px;
            font-size: 11px;
            color: #39ff14;
            z-index: 999;
            opacity: 0.7;
        }
        
        /* Mobile adjustments */
        @media (max-width: 768px) {
            #sidebar {
                position: fixed;
                height: 100vh;
                z-index: 200;
            }
            
            #ascii-banner {
                font-size: 8px;
                top: 5px;
            }
            
            .btn {
                padding: 15px;
                font-size: 14px;
            }
            
            #toggle-sidebar {
                top: 80px;
            }
        }
    </style>
</head>
<body>
    <!-- ASCII Banner -->
    <div id="ascii-banner">
 __  __    _    ___  ____    _    ____  ____  _____ _  __
|  \/  |  / \  / _ \/ ___|  / \  |  _ \| __ )| ____| |/ /
| |\/| | / _ \| | | \___ \ / _ \ | | | |  _ \|  _| | ' / 
| |  | |/ ___ \ |_| |___) / ___ \| |_| | |_) | |___| . \ 
|_|  |_/_/   \_\__\_\____/_/   \_\____/|____/|_____|_|\_\
    </div>
    
    <!-- Background watermark -->
    <div id="bg-watermark">MAQSADBEK</div>
    
    <!-- Main App -->
    <div id="app">
        <!-- Sidebar -->
        <div id="sidebar">
            <h2>‚ö° MINDMAP TOOLS ‚ö°</h2>
            <button class="btn" onclick="createNode()">‚äï New Node</button>
            <button class="btn" onclick="createChildNode()">‚äï New Child</button>
            <button class="btn danger" onclick="deleteSelectedNode()">‚äó Delete Node</button>
            <button class="btn" onclick="exportMindmap()">‚Üì Export JSON</button>
            <button class="btn" onclick="showImportModal()">‚Üë Import JSON</button>
            <button class="btn" onclick="saveToLocalStorage()">üíæ Save Local</button>
            <button class="btn" onclick="loadFromLocalStorage()">üìÇ Load Local</button>
            <button class="btn danger" onclick="clearAll()">‚ö† Clear All</button>
            <hr style="border-color: #39ff14; margin: 20px 0;">
            <div style="font-size: 11px; color: #00f5ff;">
                <p><strong>SHORTCUTS:</strong></p>
                <p>Ctrl+N: New Node</p>
                <p>Ctrl+S: Save</p>
                <p>Ctrl+O: Load</p>
                <p>Delete: Remove Node</p>
                <p>Enter: Edit Node</p>
                <p>Ctrl+/: Zoom In/Out</p>
            </div>
        </div>
        
        <!-- Toggle button -->
        <button id="toggle-sidebar" onclick="toggleSidebar()">‚ò∞</button>
        
        <!-- Canvas Container -->
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
    </div>
    
    <!-- Context Menu -->
    <div id="context-menu">
        <div class="context-item" onclick="editNodeText()">‚úé Edit Text</div>
        <div class="context-item" onclick="addChildToNode()">‚äï Add Child</div>
        <div class="context-item" onclick="duplicateNode()">‚ßâ Duplicate</div>
        <div class="context-item" onclick="changeNodeColor('green')">‚óè Green</div>
        <div class="context-item" onclick="changeNodeColor('cyan')">‚óè Cyan</div>
        <div class="context-item" onclick="changeNodeColor('purple')">‚óè Purple</div>
        <div class="context-item" onclick="deleteNode()">‚äó Delete</div>
    </div>
    
    <!-- Modal -->
    <div id="modal">
        <div class="modal-content">
            <h3 id="modal-title">Import Mindmap</h3>
            <textarea id="modal-textarea" placeholder="Paste JSON here..."></textarea>
            <div class="modal-buttons">
                <button class="btn" onclick="executeModalAction()">Confirm</button>
                <button class="btn danger" onclick="closeModal()">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Info Panel -->
    <div id="info-panel">
        <div>Nodes: <span id="node-count">0</span></div>
        <div>Zoom: <span id="zoom-level">100</span>%</div>
    </div>

    <script>
        // ========================================
        // GLOBAL STATE
        // ========================================
        
        let nodes = [];
        let connections = [];
        let selectedNode = null;
        let contextMenuNode = null;
        let draggedNode = null;
        let isDragging = false;
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let offset = { x: 0, y: 0 };
        let zoom = 1;
        let nodeIdCounter = 0;
        let modalAction = null;
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const canvasContainer = document.getElementById('canvas-container');
        const contextMenu = document.getElementById('context-menu');
        const modal = document.getElementById('modal');
        
        const COLOR_PRESETS = {
            green: '#39ff14',
            cyan: '#00f5ff',
            purple: '#b026ff'
        };
        
        // ========================================
        // INITIALIZATION
        // ========================================
        
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Mouse events
            canvasContainer.addEventListener('mousedown', handleMouseDown);
            canvasContainer.addEventListener('mousemove', handleMouseMove);
            canvasContainer.addEventListener('mouseup', handleMouseUp);
            canvasContainer.addEventListener('wheel', handleWheel, { passive: false });
            canvasContainer.addEventListener('contextmenu', handleContextMenu);
            canvasContainer.addEventListener('dblclick', handleDoubleClick);
            
            // Touch events
            canvasContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvasContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvasContainer.addEventListener('touchend', handleTouchEnd);
            
            // Keyboard
            document.addEventListener('keydown', handleKeyboard);
            
            // Click outside to close context menu
            document.addEventListener('click', () => {
                contextMenu.style.display = 'none';
            });
            
            // Start render loop
            requestAnimationFrame(render);
            
            // Load from localStorage if available
            const saved = localStorage.getItem('mindmap_state');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    importMindmapData(data);
                } catch (e) {
                    console.log('No previous state found');
                }
            } else {
                // Create initial node
                createNode(window.innerWidth / 2, 200);
            }
        }
        
        function resizeCanvas() {
            canvas.width = canvasContainer.clientWidth;
            canvas.height = canvasContainer.clientHeight;
        }
        
        // ========================================
        // NODE MANAGEMENT
        // ========================================
        
        function createNode(x = null, y = null) {
            if (x === null) {
                x = (canvas.width / 2 - offset.x) / zoom;
                y = (canvas.height / 2 - offset.y) / zoom;
            } else {
                x = (x - offset.x) / zoom;
                y = (y - offset.y) / zoom;
            }
            
            const nodeId = `node-${nodeIdCounter++}`;
            const node = {
                id: nodeId,
                x: x,
                y: y,
                width: 150,
                height: 60,
                text: 'New Node',
                color: 'green',
                element: null
            };
            
            createNodeElement(node);
            nodes.push(node);
            updateNodeCount();
            return node;
        }
        
        function createNodeElement(node) {
            const div = document.createElement('div');
            div.className = `node color-${node.color}`;
            div.id = node.id;
            div.style.left = `${node.x * zoom + offset.x}px`;
            div.style.top = `${node.y * zoom + offset.y}px`;
            
            const textSpan = document.createElement('div');
            textSpan.className = 'node-text';
            textSpan.contentEditable = false;
            textSpan.textContent = node.text;
            
            div.appendChild(textSpan);
            canvasContainer.appendChild(div);
            node.element = div;
            
            // Update node dimensions based on content
            updateNodeSize(node);
        }
        
        function updateNodeSize(node) {
            if (node.element) {
                node.width = node.element.offsetWidth;
                node.height = node.element.offsetHeight;
            }
        }
        
        function updateNodePositions() {
            nodes.forEach(node => {
                if (node.element) {
                    node.element.style.left = `${node.x * zoom + offset.x}px`;
                    node.element.style.top = `${node.y * zoom + offset.y}px`;
                    node.element.style.transform = `scale(${zoom})`;
                    node.element.style.transformOrigin = 'top left';
                }
            });
        }
        
        function deleteSelectedNode() {
            if (selectedNode) {
                deleteNodeById(selectedNode.id);
                selectedNode = null;
            }
        }
        
        function deleteNodeById(nodeId) {
            const index = nodes.findIndex(n => n.id === nodeId);
            if (index !== -1) {
                const node = nodes[index];
                if (node.element) {
                    canvasContainer.removeChild(node.element);
                }
                nodes.splice(index, 1);
                
                // Remove connections
                connections = connections.filter(c => c.from !== nodeId && c.to !== nodeId);
                updateNodeCount();
            }
        }
        
        function createChildNode() {
            if (!selectedNode) {
                alert('Please select a parent node first');
                return;
            }
            
            const parent = selectedNode;
            const child = createNode(parent.x + 200, parent.y + 100);
            
            connections.push({
                from: parent.id,
                to: child.id
            });
        }
        
        function duplicateNode() {
            if (contextMenuNode) {
                const original = contextMenuNode;
                const duplicate = createNode(original.x + 50, original.y + 50);
                duplicate.text = original.text;
                duplicate.color = original.color;
                duplicate.element.querySelector('.node-text').textContent = duplicate.text;
                duplicate.element.className = `node color-${duplicate.color}`;
            }
            contextMenu.style.display = 'none';
        }
        
        // ========================================
        // CONNECTIONS / LINES
        // ========================================
        
        function drawConnections() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            connections.forEach(conn => {
                const fromNode = nodes.find(n => n.id === conn.from);
                const toNode = nodes.find(n => n.id === conn.to);
                
                if (fromNode && toNode) {
                    const fromX = fromNode.x * zoom + offset.x + (fromNode.width * zoom) / 2;
                    const fromY = fromNode.y * zoom + offset.y + (fromNode.height * zoom) / 2;
                    const toX = toNode.x * zoom + offset.x + (toNode.width * zoom) / 2;
                    const toY = toNode.y * zoom + offset.y + (toNode.height * zoom) / 2;
                    
                    const gradient = ctx.createLinearGradient(fromX, fromY, toX, toY);
                    gradient.addColorStop(0, COLOR_PRESETS[fromNode.color] || '#39ff14');
                    gradient.addColorStop(1, COLOR_PRESETS[toNode.color] || '#39ff14');
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = COLOR_PRESETS[fromNode.color] || '#39ff14';
                    
                    ctx.beginPath();
                    ctx.moveTo(fromX, fromY);
                    
                    const midX = (fromX + toX) / 2;
                    const midY = (fromY + toY) / 2;
                    const cpX = midX;
                    const cpY = midY - 50;
                    
                    ctx.quadraticCurveTo(cpX, cpY, toX, toY);
                    ctx.stroke();
                    
                    // Arrow head
                    const angle = Math.atan2(toY - cpY, toX - cpX);
                    const arrowSize = 10;
                    ctx.beginPath();
                    ctx.moveTo(toX, toY);
                    ctx.lineTo(
                        toX - arrowSize * Math.cos(angle - Math.PI / 6),
                        toY - arrowSize * Math.sin(angle - Math.PI / 6)
                    );
                    ctx.lineTo(
                        toX - arrowSize * Math.cos(angle + Math.PI / 6),
                        toY - arrowSize * Math.sin(angle + Math.PI / 6)
                    );
                    ctx.closePath();
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                }
            });
        }
        
        // ========================================
        // EVENT HANDLERS
        // ========================================
        
        function handleMouseDown(e) {
            const clickedNode = getNodeAtPosition(e.clientX, e.clientY);
            
            if (clickedNode) {
                draggedNode = clickedNode;
                isDragging = true;
                selectedNode = clickedNode;
                
                // Update selection visuals
                nodes.forEach(n => n.element.classList.remove('selected'));
                clickedNode.element.classList.add('selected');
                
                const rect = canvasContainer.getBoundingClientRect();
                draggedNode.dragOffsetX = (e.clientX - rect.left - clickedNode.x * zoom - offset.x) / zoom;
                draggedNode.dragOffsetY = (e.clientY - rect.top - clickedNode.y * zoom - offset.y) / zoom;
            } else if (e.button === 1 || e.button === 0) {
                // Middle mouse or left mouse for panning
                isPanning = true;
                panStart.x = e.clientX - offset.x;
                panStart.y = e.clientY - offset.y;
                canvasContainer.classList.add('panning');
            }
        }
        
        function handleMouseMove(e) {
            if (isDragging && draggedNode) {
                const rect = canvasContainer.getBoundingClientRect();
                draggedNode.x = (e.clientX - rect.left - offset.x) / zoom - draggedNode.dragOffsetX;
                draggedNode.y = (e.clientY - rect.top - offset.y) / zoom - draggedNode.dragOffsetY;
                updateNodePositions();
            } else if (isPanning) {
                offset.x = e.clientX - panStart.x;
                offset.y = e.clientY - panStart.y;
                updateNodePositions();
            }
        }
        
        function handleMouseUp(e) {
            isDragging = false;
            draggedNode = null;
            isPanning = false;
            canvasContainer.classList.remove('panning');
        }
        
        function handleWheel(e) {
            e.preventDefault();
            
            if (e.ctrlKey) {
                // Zoom
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoom = Math.max(0.1, Math.min(3, zoom * delta));
                
                const rect = canvasContainer.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                offset.x = mouseX - (mouseX - offset.x) * (newZoom / zoom);
                offset.y = mouseY - (mouseY - offset.y) * (newZoom / zoom);
                
                zoom = newZoom;
                updateNodePositions();
                updateZoomDisplay();
            }
        }
        
        function handleContextMenu(e) {
            e.preventDefault();
            const clickedNode = getNodeAtPosition(e.clientX, e.clientY);
            
            if (clickedNode) {
                contextMenuNode = clickedNode;
                contextMenu.style.left = `${e.clientX}px`;
                contextMenu.style.top = `${e.clientY}px`;
                contextMenu.style.display = 'block';
            }
        }
        
        function handleDoubleClick(e) {
            const clickedNode = getNodeAtPosition(e.clientX, e.clientY);
            if (!clickedNode) {
                createNode(e.clientX, e.clientY);
            }
        }
        
        // Touch events
        let lastTouchDistance = 0;
        let touchStartTime = 0;
        
        function handleTouchStart(e) {
            touchStartTime = Date.now();
            
            if (e.touches.length === 2) {
                e.preventDefault();
                lastTouchDistance = getTouchDistance(e.touches);
                isPanning = true;
                const midpoint = getTouchMidpoint(e.touches);
                panStart.x = midpoint.x - offset.x;
                panStart.y = midpoint.y - offset.y;
            } else if (e.touches.length === 1) {
                const touch = e.touches[0];
                const clickedNode = getNodeAtPosition(touch.clientX, touch.clientY);
                
                if (clickedNode) {
                    e.preventDefault();
                    draggedNode = clickedNode;
                    isDragging = true;
                    selectedNode = clickedNode;
                    
                    nodes.forEach(n => n.element.classList.remove('selected'));
                    clickedNode.element.classList.add('selected');
                    
                    const rect = canvasContainer.getBoundingClientRect();
                    draggedNode.dragOffsetX = (touch.clientX - rect.left - clickedNode.x * zoom - offset.x) / zoom;
                    draggedNode.dragOffsetY = (touch.clientY - rect.top - clickedNode.y * zoom - offset.y) / zoom;
                }
            }
        }
        
        function handleTouchMove(e) {
            if (e.touches.length === 2) {
                e.preventDefault();
                const currentDistance = getTouchDistance(e.touches);
                const delta = currentDistance / lastTouchDistance;
                const newZoom = Math.max(0.1, Math.min(3, zoom * delta));
                
                const midpoint = getTouchMidpoint(e.touches);
                offset.x = midpoint.x - (midpoint.x - offset.x) * (newZoom / zoom);
                offset.y = midpoint.y - (midpoint.y - offset.y) * (newZoom / zoom);
                
                zoom = newZoom;
                lastTouchDistance = currentDistance;
                updateNodePositions();
                updateZoomDisplay();
                
                // Also pan
                const currentMidpoint = getTouchMidpoint(e.touches);
                offset.x = currentMidpoint.x - panStart.x;
                offset.y = currentMidpoint.y - panStart.y;
            } else if (e.touches.length === 1 && isDragging && draggedNode) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvasContainer.getBoundingClientRect();
                draggedNode.x = (touch.clientX - rect.left - offset.x) / zoom - draggedNode.dragOffsetX;
                draggedNode.y = (touch.clientY - rect.top - offset.y) / zoom - draggedNode.dragOffsetY;
                updateNodePositions();
            }
        }
        
        function handleTouchEnd(e) {
            if (e.touches.length === 0) {
                const touchDuration = Date.now() - touchStartTime;
                
                // Long press for context menu
                if (touchDuration > 500 && selectedNode && !isDragging) {
                    const rect = selectedNode.element.getBoundingClientRect();
                    contextMenuNode = selectedNode;
                    contextMenu.style.left = `${rect.left}px`;
                    contextMenu.style.top = `${rect.bottom}px`;
                    contextMenu.style.display = 'block';
                }
                
                isDragging = false;
                draggedNode = null;
                isPanning = false;
            }
        }
        
        function getTouchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function getTouchMidpoint(touches) {
            return {
                x: (touches[0].clientX + touches[1].clientX) / 2,
                y: (touches[0].clientY + touches[1].clientY) / 2
            };
        }
        
        function handleKeyboard(e) {
            // Ctrl+N: New node
            if (e.key === 'n' && e.ctrlKey) {
                e.preventDefault();
                createNode();
            }
            
            // Ctrl+S: Save
            if (e.key === 's' && e.ctrlKey) {
                e.preventDefault();
                saveToLocalStorage();
            }
            
            // Ctrl+O: Load
            if (e.key === 'o' && e.ctrlKey) {
                e.preventDefault();
                loadFromLocalStorage();
            }
            
            // Delete: Remove selected node
            if (e.key === 'Delete' && selectedNode) {
                deleteSelectedNode();
            }
            
            // Enter: Edit selected node
            if (e.key === 'Enter' && selectedNode) {
                editNodeText();
            }
            
            // Ctrl+Plus: Zoom in
            if ((e.key === '+' || e.key === '=') && e.ctrlKey) {
                e.preventDefault();
                zoom = Math.min(3, zoom * 1.1);
                updateNodePositions();
                updateZoomDisplay();
            }
            
            // Ctrl+Minus: Zoom out
            if ((e.key === '-' || e.key === '_') && e.ctrlKey) {
                e.preventDefault();
                zoom = Math.max(0.1, zoom * 0.9);
                updateNodePositions();
                updateZoomDisplay();
            }
        }
        
        // ========================================
        // HELPER FUNCTIONS
        // ========================================
        
        function getNodeAtPosition(x, y) {
            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i];
                const rect = node.element.getBoundingClientRect();
                if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                    return node;
                }
            }
            return null;
        }
        
        function updateNodeCount() {
            document.getElementById('node-count').textContent = nodes.length;
        }
        
        function updateZoomDisplay() {
            document.getElementById('zoom-level').textContent = Math.round(zoom * 100);
        }
        
        // ========================================
        // CONTEXT MENU ACTIONS
        // ========================================
        
        function editNodeText() {
            const node = contextMenuNode || selectedNode;
            if (node) {
                const textEl = node.element.querySelector('.node-text');
                textEl.contentEditable = true;
                textEl.focus();
                
                // Select all text
                const range = document.createRange();
                range.selectNodeContents(textEl);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
                
                textEl.addEventListener('blur', function() {
                    textEl.contentEditable = false;
                    node.text = textEl.textContent;
                    updateNodeSize(node);
                }, { once: true });
                
                textEl.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        textEl.blur();
                    }
                }, { once: true });
            }
            contextMenu.style.display = 'none';
        }
        
        function addChildToNode() {
            if (contextMenuNode) {
                selectedNode = contextMenuNode;
                createChildNode();
            }
            contextMenu.style.display = 'none';
        }
        
        function deleteNode() {
            if (contextMenuNode) {
                deleteNodeById(contextMenuNode.id);
                contextMenuNode = null;
            }
            contextMenu.style.display = 'none';
        }
        
        function changeNodeColor(color) {
            if (contextMenuNode) {
                contextMenuNode.color = color;
                contextMenuNode.element.className = `node color-${color}`;
                if (selectedNode === contextMenuNode) {
                    contextMenuNode.element.classList.add('selected');
                }
            }
            contextMenu.style.display = 'none';
        }
        
        // ========================================
        // IMPORT / EXPORT
        // ========================================
        
        function exportMindmap() {
            const data = {
                nodes: nodes.map(n => ({
                    id: n.id,
                    x: n.x,
                    y: n.y,
                    text: n.text,
                    color: n.color
                })),
                connections: connections,
                metadata: {
                    created: new Date().toISOString(),
                    version: '1.0'
                }
            };
            
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `mindmap_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function showImportModal() {
            modalAction = 'import';
            document.getElementById('modal-title').textContent = 'Import Mindmap';
            document.getElementById('modal-textarea').value = '';
            document.getElementById('modal-textarea').placeholder = 'Paste JSON here...';
            modal.classList.add('active');
        }
        
        function executeModalAction() {
            if (modalAction === 'import') {
                const json = document.getElementById('modal-textarea').value;
                try {
                    const data = JSON.parse(json);
                    importMindmapData(data);
                    closeModal();
                } catch (e) {
                    alert('Invalid JSON format');
                }
            }
        }
        
        function importMindmapData(data) {
            clearAll(false);
            
            nodeIdCounter = 0;
            data.nodes.forEach(nodeData => {
                const node = {
                    id: nodeData.id,
                    x: nodeData.x,
                    y: nodeData.y,
                    text: nodeData.text,
                    color: nodeData.color || 'green',
                    element: null
                };
                createNodeElement(node);
                nodes.push(node);
                
                const idNum = parseInt(node.id.split('-')[1]);
                if (idNum >= nodeIdCounter) {
                    nodeIdCounter = idNum + 1;
                }
            });
            
            connections = data.connections || [];
            updateNodePositions();
            updateNodeCount();
        }
        
        function closeModal() {
            modal.classList.remove('active');
            modalAction = null;
        }
        
        // ========================================
        // LOCAL STORAGE
        // ========================================
        
        function saveToLocalStorage() {
            const data = {
                nodes: nodes.map(n => ({
                    id: n.id,
                    x: n.x,
                    y: n.y,
                    text: n.text,
                    color: n.color
                })),
                connections: connections,
                metadata: {
                    saved: new Date().toISOString()
                }
            };
            
            localStorage.setItem('mindmap_state', JSON.stringify(data));
            alert('‚úì Mindmap saved to browser storage');
        }
        
        function loadFromLocalStorage() {
            const saved = localStorage.getItem('mindmap_state');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    importMindmapData(data);
                    alert('‚úì Mindmap loaded from browser storage');
                } catch (e) {
                    alert('Error loading saved mindmap');
                }
            } else {
                alert('No saved mindmap found');
            }
        }
        
        // ========================================
        // UI ACTIONS
        // ========================================
        
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('collapsed');
        }
        
        function clearAll(confirm = true) {
            if (confirm && !window.confirm('Clear all nodes and connections?')) {
                return;
            }
            
            nodes.forEach(node => {
                if (node.element) {
                    canvasContainer.removeChild(node.element);
                }
            });
            
            nodes = [];
            connections = [];
            selectedNode = null;
            updateNodeCount();
        }
        
        // ========================================
        // RENDER LOOP
        // ========================================
        
        function render() {
            drawConnections();
            requestAnimationFrame(render);
        }
        
        // ========================================
        // START
        // ========================================
        
        init();
    </script>
</body>
</html>
